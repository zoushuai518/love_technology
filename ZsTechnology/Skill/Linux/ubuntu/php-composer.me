#===
以下安装在 ubuntu平台下测试通过：
#===
[
zs:
$cd /usr/local/nginx/html  
$curl -s http://getcomposer.org/installer| php
$sudo mv composer.phar /usr/bin/composer
{

bgm composer.json配置：|仅供参考
{
    "autoload": {
  	     "psr-0": {
				      "Base": "src",
				       "Components" : "src",
				       "Config" : "src",
			         "Controllers" : "src",
			         "Models" : "src"
			   }   
	 },  
	 "require": {
			  "phpunit/phpunit": "3.7.*",
			  "gabordemooij/redbean": "dev-master",
			  "phpfastcache/phpfastcache": "dev-Stable-Version-1.x",
			  "corneltek/pux": "~1.3",
			  "rain/raintpl": ">=3.0.0",
			  "kohana/cache": "3.3.*@dev",
			  "monolog/monolog": "1.7.*@dev"
   }   
}

}
$composer install
]

#===
#--
composer包管理器

安装
Composer包含两大逻辑部分：一个是用来存储包，另一个是命令行应用程序，帮助你发现、下载、更新和分享代码
$cd/path/to/my/project  
$curl -s http://getcomposer.org/installer| php

在项目列表中，会有一个composer.phar文件，里面包含了所有逻辑代码行工具。你可以通过运行下面代码来确定是否安装成功
$php composer.phar
这个命令执行后会显示所有可用的命令

我个人比较建议大家使用这个命令：
$sudo mv composer.phar /usr/bin/composer
把这个文件移到bin目录下，它允许你简化命令
$composer about

#--

解析composer.json文件

如果你是一名Ruby程序员，你会觉得这个文件跟Gemfile文件很相似，或者你是一个Node程序员，那么会觉得和package.json文件很像。同样，Composer会根据你的应用需求用composer.json文件来指定设置和封装。

在大多数基本的form里面，composer文件看起来是这样的：

{  
    "require": {  
		     "kriswallsmith/assetic": "*"  
	  }  
} 

意思是需要一个“assetic”包，通过“kriswallsmith”创建和指定任意一个版本。你也可以指定一个特殊的版本，你可以使用下面命令代替：
"kriswallsmith/assetic": "1.0.3"
你甚至还可以使用这种方法：
"kriswallsmith/assetic": "1.0.*"
这个有一些微小的变化，但是他不会升级到1.1.0，程序员需要注意界面上细微的变化
安装要求

现在，在你的composer.json文件下面会有一个或多个包，这个时候可以运行：
$php composer.phar install 

或者，如果你听了我的建议，你只需要在Unix机器上面运行：
$composer install

你会发现，正在下载文件并且会放在应用程序根目录下面的vendors文件夹里面。这个逻辑也可以使用下面的配置：

{  
    "require": {  
		     "kriswallsmith/assetic": "1.0.*"  
	  },  
	  "config" : {  
	       "vendor-dir" : "packages"  
	  }  
} 

#--

自动加载

自动加载在PHP里面有一点乱糟糟的，作为开发人员，他们有属于自己操作方式。比如Smarty包，使用自己的自动载入。有一些开发人员会把多个类放到一个文件里面，或者文件名小写，这些做法都太随意啦！

PHP官方社区创建了PSR-0标准，从而来规范这些随意的做法。Composer默认支持这个标准。Composer里面自带PSR-0自动加载机制，在项目里面加入下面一行代码：

include_once './vendor/autoload.php'; 
显然，如果autoload.php文件目录有变化，你也需要在代码里面做出相应改动。

下面，你可以在应用程序中使用如下代码：

<?
php   
use Assetic\Asset\AssetCollection;  
use Assetic\Asset\FileAsset;  
use Assetic\Asset\GlobAsset;  
$js = new AssetCollection(array(  
   new GlobAsset('/path/to/js/*'),  
   new FileAsset('/path/to/another.js'),  
));  
				   
// the code is merged when the asset is dumped  
echo $js-
>

dump();  

#-
这是一个使用Assetic的例子，当然，这里也有许多命名空间代码，但是这样做是为了避免包之间互相冲突。

PSR-0的命名惯例本质是：

\
<
Vendor Name
>
\(
<
Namespace
>
\)*
<
Class Name
>

#-

下面这个例子是Buzz HTTP包：

er = new Buzz\Browser;  
$response = $browser-
>
get('http://www.google.com');  
echo $browser-
>
getLastRequest()."\n";  
echo $response; 

看起来像是被美化的file_get_contents()，但是它处理所有类型的智能逻辑，并且在后台处理HTTP Response/Request，你也会发现命名空间语法也不是那么的强烈

#-- 注：
真实的世界

目前，大多数PHP存储依靠主代码库。如果你使用Facebook SDK，例如，你仅仅从GitHub或者zip文件中通过复制粘贴的方式把版本推到你的代码中，然后把它放到你的版本控制系统里面，将会变更。

版本和你的代码只是作为静态文件放在里面，在某种意义上，你可能会忘记升级，如果你关注到Facebook已经发布了一个新版本。最新版本文件会显示在最上面。

使用Composer就无需关注版本变化情况，你只需运行一下更新，那么所有需要更新的都会自动更新。但是为什么还会有大量的代码在你的仓库里呢？你不需要它们在那里吗？

最干脆的做法是添加vendors到你的“Ignore”列表里面（例如gitignore）并且让你的代码完全离开那里。当你在部署代码的时候，你只需运行composer install或者composer update。

如果你想使用更熟练，你可以手动运行整个过程，如果你有云端托管你可以设置hooks，一旦代码发布，就运行。

总结

将来，你将会看到更多的Composer，各种丰富多彩的框架已经开始提供了多种层次的集成。FuelPHP将构建Composer包，CodeIgniter提供自动加载并且已经在Symfony2上广泛使用。

使用Composer添加相关包到你的项目里面是一个很好的方式，无需安装PECLI扩展或者复制粘贴一个系列文件。那种方式已经很过时了，并且还浪费你大量的时间




